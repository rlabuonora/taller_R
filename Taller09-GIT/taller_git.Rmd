---
title: "Taller git"
author: "Paula Pereda"
date: "10/05/2018"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["default", "rladies", "rladies-fonts"]
    nature:
          highlightLines: true
countIncrementalSlides: false  
enableEmoji: true
---

> "Usar un sistema de control de versiones (VCS) es una necesidad b√°sica para los desarrolladores de hoy y se espera que cada desarrollador tenga el conocimiento (al menos, de los conceptos b√°sicos) de cualquier VCS. Por lejos, el sistema de control de versi√≥n moderno m√°s utilizado en el mundo hoy en d√≠a es GIT. GIT y  [Github](https://github.com/) han hecho la vida de los desarrolladores mucho m√°s sencilla, tanto que simplemente darles las gracias, no ser√° suficiente".

En otras palabras, nos permite evitar esto:

.pull-left[
![](https://cdn-images-1.medium.com/max/1600/1*wW5dcnXhZ72U-M3ChEDQbg.gif)]

.pull-right[
![](http://phdcomics.com/comics/archive/phd052810s.gif)]

---

# **Pero... ¬øa qu√© nos referimos cuando nos referimos a control de versiones?**

Un control de versiones puede entenderse como:
- un sistema que mantiene un registro de sus cambios 
- permite un entorno para el desarrollo colaborativo
- permite saber qui√©n hizo qu√© cambios y cu√°ndo
- **y lo m√°s importante:** nos permite revertir cualquier cambio y volver a un estado previamente guardado


# **Entonces...**

- podemos experimentar con c√≥digos sin romper el proyecto principal üíú
- mantener todo el historial de un archivo e inspeccionar un archivo a lo largo de su vida √∫til
- etiquetar una versi√≥n en particular para que puedas volver a ellas f√°cilmente
- facilitar las colaboraciones y hace que las contribuciones sean transparentes

---
class: inverse

# **Caracter√≠sticas del control de versiones**

- **Reproducibilidad**: registro de cada paso, completar el historial del proyecto

- **Tranquilidad**: un sistema de copia de seguridad robusto de archivos cambiantes

- **Colaboraci√≥n**: sincroniza los mismos archivos en varias computadoras y/o personas

---

# **¬øQu√© es git?**

.pull-left[
![](git.png)]


.pull-right[Git es una implementaci√≥n especial de control de versiones. Es muy poderosa y tiene muchas caracter√≠sticas √∫tiles.]

---

#¬°A considerar!


- Es importante pensar en t√©rminos de ‚Äúcambios‚Äù a los archivos
- Tambi√©n es importante ser disciplinado
- Cuando las cosas se complican es cuando $git$ m√°s sirve, pero es m√°s probable que perdamos la disciplina (proyectos grandes, problemas dif√≠ciles)

#Ventajas

- Es un undo infinito (si lo usamos bien)
- Permite que todos trabajemos sobre el mismo conjunto de archivos
- Permite tener varias copias del c√≥digo (puedo experimentar y aprender sobre el problema que estoy tratando de resolver, tirar todo, y despu√©s crear una soluci√≥n)
---


#Conceptos b√°sicos

- $Working$ $directory:$ es el estado actual de los archivos en el disco duro

- $Staging$ $area:$ limbo donde pongo todos los cambios antes de $commitearlos$

- $Commit:$ un conjunto de cambios (sustantivo)

- $Commit:$ guardar un conjunto de cambios en la historia del repo (verbo)


üìç Los comandos tienen opciones que modifican (sustancialmente) lo que hacen.

---
#Nos introducimos a Git

```{r, eval=FALSE}
$ git config --global user.name 'Paula Pereda'
$ git config --global user.email 'ppereda@transformauruguy.gub.uy'
$ git config --global --list
```

---

#Kit de supervivencia

- Iniciar un repositorio
- Agregar y commitear
- Recuperar versiones anteriores

#Lo b√°sico:

- cre√°s/edit√°s/modific√°s un archivo dentro de su repositorio 
- realiz√°s los cambios en el $staging$ $area$ 
- $commite√°s$ estos cambios, lo que crea una instant√°nea permanente del archivo en el directorio de $Git$ junto con un mensaje que indica lo que le hiciste al archivo

---

# 1) Crear un nuevo repositorio

Cre√° un directorio nuevo, abrilo y ejecut√° para crear un nuevo repositorio de $git$:

```{r, eval=FALSE}
$ git init
```

# 2) Hacer checkout a un repositorio

Crea una copia local del repositorio ejecutando:

```{r, eval=FALSE}
$ git clone /path/to/repository
```

Si utiliz√°s un servidor remoto como $git$ o $Bitbucket$, ejecut√°:

```{r, eval=FALSE}
$ git clone username@host:/path/to/repository
```
---
#Flujo de trabajo b√°sico

Cuando comienza un nuevo proyecto, los archivos en su directorio de trabajo no se rastrean, primero ten√©s que agregarlos a tu repositorio antes de que Git pueda hacer un seguimiento de ellos y su historial. En esta etapa, todo est√° todav√≠a en su disco duro. Para cargar sus modificaciones (es decir, sus $commits$) a $GitHub$ necesit√°s hacer $push$. Si est√°s trabajando con otras personas, tambi√©n est√°s commiteando tu repositorio compartido en GitHub, ten√©s que hacer $push$ para traer sus modificaciones a su copia local del repositorio. **Los compromisos son baratos. Comittee a menudo y proporcione mensajes √∫tiles para que pueda realizar un seguimiento de lo que est√° haciendo.** No hagas esto:

.pull-bottom[
![](http://imgs.xkcd.com/comics/git_commit.png)]


---
#Flujo de trabajo

Tu repositorio local est√° compuesto por tres "√°rboles" administrados por $git$:

1) el $directorio$ $de$ $trabajo$ que contiene los archivos

2) el $index$ que act√∫a como una zona intermedia

3) el $HEAD$ que apunta al √∫ltimo commit realizado


![](http://rogerdudler.github.io/git-guide/img/trees.png)
---

# add & commit

Puedes registrar cambios (a√±adirlos al $Index$) usando:

```{r, eval=FALSE}
$ git add <filename>
$ git add .
```
Este es el primer paso en el flujo de trabajo b√°sico. Para hacer $commit$ a estos cambios us√°:

```{r, eval=FALSE}
$ git commit -m "Commit message"
```

Ahora el archivo est√° inclu√≠do en el $HEAD$, pero a√∫n no en tu repositorio remoto. 
---

#Env√≠o de cambios

Tus cambios est√°n ahora en el $HEAD$ de tu copia local. Para enviar estos cambios a tu repositorio remoto ejecut√°:
```{r, eval=FALSE}
git push origin master
```

(!) Se puede reemplazar $master$ por la rama a la que quieres enviar tus cambios.

Si no clonaste un repositorio ya existente y quieres conectar tu repositorio local a un repositorio remoto, us√°:

```{r, eval=FALSE}
$ git remote add origin <server>
```  

Ahora pod√©s subir tus cambios al repositorio remoto seleccionado.
---

#Ramas (branches)

- son utilizadas para desarrollar funcionalidades aisladas unas de otras

- la rama $master$ es la rama "por defecto" cuando creas un repositorio

- se puede crear nuevas ramas durante el desarrollo y $mergearlas$ (fusionarlas) a la rama principal cuando termines

.pull-center[
![](http://rogerdudler.github.io/git-guide/img/branches.png)]

---

#Ramas (branches) II

Cre√° una nueva rama llamada "feature_x" y cambiate a ella usando:

```{r, eval=FALSE}
$ git checkout -b feature_x
``` 

Para volver a la rama principal:

```{r, eval=FALSE}
$ git checkout master
```

Y para borrar la rama:

```{r, eval=FALSE}
$ git branch -d feature_x
```

$Importante:$ la rama nueva no estar√° disponible para los dem√°s a menos que subas ($push$) la rama a tu repositorio remoto:

```{r, eval=FALSE}
$ git push origin <branch>
```
---

#actualiz√° (push) & fusion√° (merge)

Para actualizar tu repositorio local al $commit$ m√°s nuevo, ejecut√°:

```{r, eval=FALSE}
$ git pull
```

Para fusionar otra rama a tu rama activa (por ejemplo $master$), utiliz√°:

```{r, eval=FALSE}
$ git merge <branch>
```
En ambos casos $git$ intentar√° fusionar autom√°ticamente los cambios. Desafortunadamente, no siempre ser√° posible y se podr√°n producir conflictos. En caso de conflicto, uno es responsable de fusionar esos conflictos manualmente al editar los archivos mostrados por $git$. Despu√©s de modificarlos, necesit√°s marcarlos como fusionados con:

```{r, eval=FALSE}
$ git add <filename>
```  
  
Antes de fusionar los cambios, puedes revisarlos usando:
  
```{r, eval=FALSE}  
$ git diff <source_branch> <target_branch>
```

---

#Reemplazando cambios locales

En caso de que hagas algo mal (lo que seguramente nunca suceda üòâ) pod√©s reemplazar cambios locales usando el comando:

```{r, eval=FALSE} 
$ git checkout -- <filename>
```

Este comando reemplaza los cambios en tu directorio de trabajo con el √∫ltimo contenido de $HEAD$. Los cambios que ya han sido agregados al $Index$, as√≠ como tambi√©n los nuevos archivos, se mantendr√°n sin cambio.



Por otro lado, si quer√©s deshacer todos los cambios locales y $commits$, pod√©s traer la √∫ltima versi√≥n del servidor y apuntar a tu copia local principal de esta forma:

```{r, eval=FALSE} 
$ git fetch origin
$ git reset --hard origin/master
```
---

# Ejemplo

Tengo un archivo:

```{r, eval=FALSE} 
main.R
```

Inicio un nuevo repositorio:

```{r, eval=FALSE} 
$ git init # crea el repo
```

Agregar cambios al $staging$ $area$:

```{r, eval=FALSE} 
$ git add main.R # agrega (los cambios en) main al "staging area"
```

Commitear todo lo $stageado$:

```{r, eval=FALSE} 

$ git commit -m "Commit inicial" # commiteo cambios que hay en la staging area
```
---

#Flujo de Trabajo

Hacemos algunos cambios:

```{r, eval=FALSE} 

# Un script para calcular exportaciones por sector:

library(tibble)

sectores <- tibble(ciiu = c("0111", "0110", "0112"),
                   giro = c("arroz", "soja", "carne"))

expors <- tibble(empresa = c("ZZZ", "YYY", "XXX", "WWW", "NNN"),
                 expors = c(10000, 9000,    8000, 3000, 1000 ))
```

Para ver las diferencias entre working y el √∫ltimo $commit$:

```{r, eval=FALSE} 
$ git diff
```
---

#Me gustan los cambios

$git$ $status$ me da un res√∫men de estos cambios, para agregarlos al $staging$ $area$:

```{r, eval=FALSE} 
$ git add main.R
```
Ahora $git$ $status$ cambia: ¬°Ô∏ètengo cambios stageados listos para ser commiteados!

Para commitear:

```{r, eval=FALSE} 
$ git commit -m "Agrega data frames"
```

üìç Ahora $git$ $status$ dice que no hay cambios.

---

#Ejercicio: otro cambio

1) Agrego la empresa ‚ÄúRRR‚Äù que exporta 5000

2) Escenarios:

  - Hago el cambio y lo deshago
  
  - Hago el cambio, lo stageo y lo deshago
  
  - Hago el cambio, lo comiteo y lo deshago
---

# Primer escenario

Lo quiero deshacer sin haber hecho nada m√°s que cambiar el working directory.

Interpretar:

```{r, eval=FALSE} 
$ git status
```

Interpretar:

```{r, eval=FALSE} 
$ git diff
```


Deshacer cambio:

```{r, eval=FALSE} 
$ git checkout main.R
```

Saca la √∫ltima versi√≥n comitteada de un archivo.

üìç Ahora: $git$ $status$ y $git$ $diff$ est√°n ‚Äúlimpios‚Äù

---

# Segundo escenario

Hago el cambio y lo stageo:

```{r, eval=FALSE} 
$ git add main.R
```

¬øY ahora? $git$ $diff$ ya no da nada ¬°Tengo cambios para ser commiteados!

```{r, eval=FALSE} 
$ git reset HEAD main.R # destagear cambios
$ git checkout main.R  # ahora estoy igual que en el anterior
```
---

# Tercer escenario

Hago el cambio, lo stageo y lo commiteo.

¬øMemoria?

---

#Deshacer cambios commiteados con revert

Sirve para dejar los logs de haber deshecho el commit:

```{r, eval=FALSE} 
$ git revert HEAD
```

#Deshacer cambios commiteados con reset

```{r, eval=FALSE} 
$ git reset --hard HEAD^1
```
---

#Repositorios remotos con Github

Descargamos las diapos desde $Github$:

$ git clone https://github.com/rlabuonora/taller_R.git

Hago un cambio y lo subo.

Hago el cambio:

```{r, eval=FALSE} 
$ git add README.md
$ git commit -m "Cambio en README"
```

Y lo mando (me pide credenciales $Github$ y tengo que tener permiso del admin del repo):

```{r, eval=FALSE}
$ git push origin master
```


